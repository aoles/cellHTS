\begin{Schunk}
\begin{Sinput}
> library("biomaRt")
\end{Sinput}
\end{Schunk}
%
By default, the \Rpackage{biomaRt} package will query the webservice at\newline 
http://www.ebi.ac.uk/biomart/martservice.  Let us check
which BioMart databases it covers:
%
\begin{Schunk}
\begin{Sinput}
> listMarts()
\end{Sinput}
\begin{Soutput}
$biomart
[1] "dicty"    "ensembl"  "snp"      "vega"     "uniprot"  "msd"      "wormbase"

$version
[1] "DICTYBASE (NORTHWESTERN)"    "ENSEMBL 40 (SANGER)"        
[3] "SNP 40 (SANGER)"             "VEGA 40 (SANGER)"           
[5] "UNIPROT PROTOTYPE 4-5 (EBI)" "MSD PROTOTYPE 4 (EBI)"      
[7] "WORMBASE CURRENT (CSHL)"    

$host
[1] "www.dictybase.org" "www.biomart.org"   "www.biomart.org"  
[4] "www.biomart.org"   "www.biomart.org"   "www.biomart.org"  
[7] "www.biomart.org"  

$path
[1] ""                     "/biomart/martservice" "/biomart/martservice"
[4] "/biomart/martservice" "/biomart/martservice" "/biomart/martservice"
[7] "/biomart/martservice"

$vschema
[1] "dicty"   "default" "default" "default" "default" "default" "default"
\end{Soutput}
\end{Schunk}
%
In this example, we use the Ensembl database~\cite{Ensembl2006}, from
which we select the \textit{D. melanogaster} dataset.
%
\begin{Schunk}
\begin{Sinput}
> mart = useMart("ensembl")
\end{Sinput}
\end{Schunk}
% 
\begin{Schunk}
\begin{Sinput}
> listDatasets(mart = mart)
\end{Sinput}
\begin{Soutput}
                      dataset    version
1     gaculeatus_gene_ensembl           
2      lafricana_gene_ensembl           
3    scerevisiae_gene_ensembl       SGD1
4  cintestinalis_gene_ensembl       JGI2
5   ptroglodytes_gene_ensembl    CHIMP1A
6      etelfairi_gene_ensembl           
7     ocuniculus_gene_ensembl           
8       hsapiens_gene_ensembl     NCBI36
9        ggallus_gene_ensembl    WASHUC1
10 tnigroviridis_gene_ensembl TETRAODON7
11      mmulatta_gene_ensembl     MMUL_1
12       btaurus_gene_ensembl   Btau_2.0
13      aaegypti_gene_ensembl           
14   rnorvegicus_gene_ensembl    RGSC3.4
15     csavignyi_gene_ensembl           
16      celegans_gene_ensembl     CEL150
17     trubripes_gene_ensembl      FUGU4
18 dnovemcinctus_gene_ensembl           
19      agambiae_gene_ensembl     AgamP3
20   xtropicalis_gene_ensembl     JGI4.1
21        drerio_gene_ensembl     ZFISH6
22    mdomestica_gene_ensembl    BROADO3
23 dmelanogaster_gene_ensembl    BDGP4.3
24     mmusculus_gene_ensembl    NCBIM36
25   cfamiliaris_gene_ensembl    BROADD1
\end{Soutput}
\end{Schunk}
%
\begin{Schunk}
\begin{Sinput}
> mart = useDataset("dmelanogaster_gene_ensembl", mart)
\end{Sinput}
\end{Schunk}
%
We can query the available gene attributes and filters for the
selected dataset using the following functions.
\begin{Schunk}
\begin{Sinput}
> attrs = listAttributes(mart)
> filts = listFilters(mart)
\end{Sinput}
\end{Schunk}
%
In the BioMart system~\cite{Kasprzyk2004}, a \emph{filter} is a
property that can be used to select a gene or a set of genes (like the
``where'' clause in an SQL query), and an \emph{attribute} is a
property that can be queried (like the ``select'' clause in an SQL
query). We use the \Rfunction{getBM} function of the package
\Rpackage{biomaRt} to obtain the gene annotation from Ensembl.
%
\begin{Schunk}
\begin{Sinput}
> myGetBM = function(att) getBM(attributes = c("ensembl_gene_id", 
+     att), filter = "ensembl_gene_id", values = unique(x$geneAnno$GeneID), 
+     mart = mart)
\end{Sinput}
\end{Schunk}
% 
For performance reasons, we split up our query in three subqueries,
which corresponds to different areas in the BioMart schema, and then
assemble the results together in R.  Alternatively, it would also be
possible to submit a single query for all of the attributes, but then
the result table will be enormous due to the 1:many mapping
especially from gene ID to GO categories~\cite{GO}.
%
\begin{Schunk}
\begin{Sinput}
> bm1 = myGetBM(c("chromosome_name", "start_position", "end_position", 
+     "description"))
> bm2 = myGetBM(c("flybase_name"))
> bm3 = myGetBM(c("go", "go_description"))
\end{Sinput}
\end{Schunk}
%
There are only a few CG-identifiers for which we were not able to
obtain chromosomal locations: 
%
\begin{Schunk}
\begin{Sinput}
> unique(setdiff(x$geneAnno$GeneID, bm1$ensembl_gene_id))
\end{Sinput}
\begin{Soutput}
 [1] NA        "CG7245"  "CG32253" "CG6735"  "CG31314" "CG31085" "CG15509"
 [8] "CG15388" "CG15389" "CG5061"  "CG5074"  "CG31722" "CG31756" "CG4110" 
[15] "CG15280" "CG31766" "CG11169" "CG13596" "CG18510" "CG12557" "CG14493"
[22] "CG5719"  "CG14499" "CG14501" "CG4383"  "CG13904" "CG1211"  "CG13289"
[29] "CG13290" "CG7973"  "CG7867"  "CG6112"  "CG13444" "CG18648" "CG13459"
[36] "CG5571"  "CG31350" "CG6989"  "CG18553" "CG32469" "CG11676" "CG12600"
[43] "CG7552"  "CG12537" "CG14559" "CG15507" "CG15781" "CG15348" "CG15349"
[50] "CG5652"  "CR33460" "CR33465" "CG30322" "CR33258"
\end{Soutput}
\end{Schunk}
%
Below, we add the results
to the dataframe \Robject{x\$geneAnno}. Since the tables \Robject{bm1},
\Robject{bm2}, and \Robject{bm3} contain zero, one or several rows for
each gene ID, but in \Robject{x\$geneAnno} we want exactly one row per
gene ID, the function \Rfunction{oneRowPerId} does the somewhat tedious
task of reformatting the tables: multiple entries are collapsed
into a single comma-separated string, and empty rows are inserted
where necessary.
%
\begin{Schunk}
\begin{Sinput}
> id = x$geneAnno$GeneID
> bmAll = cbind(oneRowPerId(bm1, id), oneRowPerId(bm2, id), oneRowPerId(bm3, 
+     id))
> bdgpbiomart = cbind(x$geneAnno, bmAll)
> x$geneAnno = bdgpbiomart
\end{Sinput}
\end{Schunk}

%% This is how the object is then saved in the data subdirectory of the package:

